#lab1 report

##［prac1］:
#1、make调用了gcc把.c源代码编译成.o文件，然后通过ld将目标文件转换成一个执行程序。
>最后用dd把执行程序bootloader放到一个虚拟的硬盘ucore.img里去。
qemu会根据硬盘里面的数据来执行相应的代码。

#2、小于等于512个字节，
>且第510个字节是0x55，第511个字节是0xAA。


##［prac2］:
#使用nexti和stepi，可以进行单步调试工作。
>nexti：单步一条机器指令，不进入函数。
stepi：单步一条机器指令，包括进入函数。

##［prac3］:
#1、为何开启A20和如何开启A20？
>为何要开启A20：通过修改A20地址线可以完成从实模式到保护模式的转换。CPU如果遇到寻址超过1MB的情况，系统不会再回卷，会造成向下不兼容。为了保持向下兼容，加入A20 Gate这个硬件逻辑，来模仿回绕特征。
如何开启A20：将A20地址线控制和键盘控制器的一个输出进行AND操作。通过将键盘控制器上的A20线置于高电位，全部32条地址线可用。

#2、如何初始化GDT表？
>一个简单的GDT表和其描述符已经静态储存在引导区中，载入即可，通过lgdt gdtdesc来初始化。
第一个段描述符设定为空段描述符。GDTR中的段界限以字节为单位，对于含有N个描述符的描述符表的段界限设置为8*N－1.

#3、如何使能和进入保护模式？
>通过将cr0寄存器PE位置1便开启了保护模式，通过长跳转更新cs的基地址，设置段寄存器，并建立堆栈，
转到保护模式完成，进入boot主方法。

##［prac4］:
#1、bootloader如何读区硬盘扇区的？
>一般主板有两个IDE通道，每个通道可以接2个IDE硬盘。
当前硬盘数据时储存到硬盘扇区中的，一个扇区大小为512字节。
>读一个硬盘扇区的流程为：
（1）等待磁盘准备好（2）发出读取扇区的命令（3）等待磁盘准备好（4）把磁盘扇区数据读到指定内存

#2、bootloader如何加载ELF格式的OS？
>读取了ELF文件的header，判断它的一个特殊的成员变量emagic是否等于一个特定的值，以确定它是一个合法的ELF格式的文件，根据proghdr来读取相应的代码段和数据段，加到相应的地方去。最后bootloader加载完ucore之后跳到一个指定的地方去。


##［prac5］:
#取出函数调用栈里的ebp和eip，并且输出从下到上4个参数。
ss:ebp指向的堆栈位置储存着caller的ebp，以此为线索可以得到所有使用堆栈的函数ebp。
ss:ebp+4指向caller调用时的eip，ss:ebp+8等是可能的参数。

##［prac6］:
#1、中断向量表中一个表项占多少字节？其中哪几位代表中断处理代码的入口？
>8字节，其中2-3字节是段选择子，0-1字节和6-7字节拼成位移。两者联合便是中断处理程序的入口地址。

#2／3、见代码。