# Lab7 report

计23
林子钏
2012011322

### 练习0
---
1. 	<b>添加lab1~lab6原有代码，并进行适当更新。</b>

	> * trap_dispatch() in trap.c
	```
	ticks ++;
      assert(current != NULL);
      run_timer_list();
      break;
	```

### 练习1
---
1.	<b>理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题</b>
	
	> * lab7内核级信号量的设计描述，和其大致执行流流程
	```
	内核级信号量的数据结构为如下：
	typedef struct {
          int value;
          wait_queue_t wait_queue;
      } semaphore_t;
      信号量的设计：主要是通过信号量中的value值来查看资源的使用情况以及进程等待队列的情况。
      当value>=1时，说明有空闲的资源可以使用，value=空闲的资源数;
      当value<=0时，说明资源不够用，进程必须进入等待队列，-value=等待进程的个数。
      大致执行流程：
      （1）sem_init(&mutex, 1)初始化信号量mutex，用来表示每次只允许一个哲学家进程进行拿筷子的操作;
      （2）然后对每一个进程都初始化一个对应的信号量sem_init(&s[i], 0)，用来表示每一个哲学家的状态是否可以变化;
      （3）当有一个哲学家要take时，先要根据mutex的信号量使得其他进程阻塞，然后将哲学家状态变成hungry，再检测是否可以拿到叉子，并且退出mutex的临界区，并且根据信号量s[i]的值来选择哲学家的状态是否需要阻塞。
      （4）当有一个哲学家要put时，也要先根据mutex的信号量进入临界区，将状态变成thinking，并尝试唤醒左右两边的哲学家，最后释放mutex信号量。
	```

	> * 用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。
	```
	用自旋锁实现信号量。当进程所需的资源得不到满足时，使该进程一直在CPU中运行检测直到资源信号量资源得到满足。
	与内核级提供信号量机制比较，
	相同点：都使用信号量来表示资源的使用情况;
	不同点：省去了进程进入等待队列所需要进行的上下文切换等操作，使得在用户态的执行效率较高。
	```

### 练习2
---
1.	<b>完成内核级条件变量和基于内核级条件变量的哲学家就餐问题</b>
	
	> * 内核级条件变量的设计描述，并说其大致执行流流程。
	```
	条件变量的数据结构如下：
	typedef struct monitor{
          semaphore_t mutex;      
          semaphore_t next;       
          int next_count;         
          condvar_t *cv;          
      } monitor_t;
	大致执行流程：
	与之前信号量的差不多，区别在于管程把零散的信号量的操作统一起来了，并且用条件变量来表示资源是否满足进程的需要。
	```

	> * 给用户态进程/线程提供条件变量机制的设计方案，并比较说明给内核级提供条件变量机制的异同。
	```
      用自旋锁实现条件变量。当进程所需的资源得不到满足时，使该进程一直在CPU中运行检测直到条件变量得到满足。
	与内核级提供条件变量机制比较，
	相同点：都使用条件变量来表示进程所需的资源是否能够得到满足。
	不同点：省去了进程进入等待队列所需要进行的上下文切换等操作，使得在用户态的执行效率较高。
	```





