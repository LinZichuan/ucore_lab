#lab5 report

##练习1: 加载应用程序并执行（需要编码）
---
###设计实现过程：
```
trapframe中先全体置零
再来cs段皆为用户代码段
对应的ds,es,ss也都是用户数据段
而esp就是指向用户栈栈顶
eip则指向elf可执行文件的入口
eflags则则设置成允许中断
```
```
首先ucore通过schedule()从当前的进程列表中选择到该进程
接着调用proc_run()进行相关特殊寄存器以及上下文的切换
在调用switch_to()时
函数的return address被设置为该进程对应的eip内容
它在之前创建该进程时设置成为该进程对应代码段入口
所以在函数返回后,CPU跳到对应位置开始执行该进程的第一条指令
```

##练习2：父进程复制自己的内存空间给子进程
---
###设计实现过程
```
对应父进程每一代码页在子进程内存空间内申请并复制相同内容
然后添加对应的页表记录项
```
###COW概要设计
```
对每一资源进行计数,记录当前其使用者的数量,当某使用者要对资源进行写操作时
先检查该计数,如为1则说明资源为该使用者独享,可以直接进行修改
不然说明该资源为多使用者共享,要对资源进行拷贝后再作修改,并同时减少该计数
```
##练习3：阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现
---
``` 
fork和exec并没有影响到当前进程的执行状态
wait则当父进程有子进程但无僵尸子进程时将父进程休眠并让出CPU
其余情况也不影响当前进程的执行状态
exit则释放进程资源,设置进程为僵尸并根据情况唤醒相关父进程,让出CPU
 alloc_proc            wakeup_proc              do_wait              do_exit
|---------->PROC_UNINIT----------->PROC_RUNNABLE------->PROC_SLEEPING------->PROC_ZOMBIE
                                   +do_exit             +do_exit
                                   +------->PROC_ZOMBIE +------->PROC_RUNNABLE
```
